<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Plot smart charging results — plot_smart_charging • flextools</title><!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png"><link rel="icon" type="”image/svg+xml”" href="../favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png"><link rel="icon" sizes="any" href="../favicon.ico"><link rel="manifest" href="../site.webmanifest"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Plot smart charging results — plot_smart_charging"><meta name="description" content="HTML interactive plot showing the comparison between the smart charging setpoint
and the actual EV demand after the smart charging program. Also, it is possible
to plot the original EV demand."><meta property="og:description" content="HTML interactive plot showing the comparison between the smart charging setpoint
and the actual EV demand after the smart charging program. Also, it is possible
to plot the original EV demand."><meta property="og:image" content="https://resourcefully-dev.github.io/flextools/logo.png"><!-- dependencies from examples --><script src="libs/htmlwidgets-1.6.4/htmlwidgets.js"></script><link href="libs/dygraphs-1.1.1/dygraph.css" rel="stylesheet"><script src="libs/dygraphs-1.1.1/dygraph-combined.js"></script><script src="libs/dygraphs-1.1.1/shapes.js"></script><script src="libs/moment-2.8.4/moment.js"></script><script src="libs/moment-timezone-0.2.5/moment-timezone-with-data.js"></script><script src="libs/moment-fquarter-1.0.0/moment-fquarter.min.js"></script><script src="libs/dygraphs-binding-1.1.1.6/dygraphs.js"></script></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">flextools</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/flextools.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Optimization problems</h6></li>
    <li><a class="dropdown-item" href="../articles/minimize_net_power.html">Net power optimization</a></li>
    <li><a class="dropdown-item" href="../articles/minimize_cost.html">Energy cost optimization</a></li>
    <li><a class="dropdown-item" href="../articles/combined_optimization.html">Combined optimization</a></li>
    <li><a class="dropdown-item" href="../articles/parallel-processing.html">Parallel processing</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Demand-response</h6></li>
    <li><a class="dropdown-item" href="../articles/smart-charging.html">Smart charging</a></li>
    <li><a class="dropdown-item" href="../articles/smart-charging-advanced.html">Advanced smart charging</a></li>
    <li><a class="dropdown-item" href="../articles/user-profiles.html">User profiles in smart charging</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><a class="external-link nav-link" href="https://github.com/resourcefully-dev/flextools/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Plot smart charging results</h1>
      <small class="dont-index">Source: <a href="https://github.com/resourcefully-dev/flextools/blob/HEAD/R/smart-charging.R" class="external-link"><code>R/smart-charging.R</code></a></small>
      <div class="d-none name"><code>plot_smart_charging.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>HTML interactive plot showing the comparison between the smart charging setpoint
and the actual EV demand after the smart charging program. Also, it is possible
to plot the original EV demand.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">plot_smart_charging</span><span class="op">(</span></span>
<span>  <span class="va">smart_charging</span>,</span>
<span>  sessions <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  show_setpoint <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  by <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-smart-charging">smart_charging<a class="anchor" aria-label="anchor" href="#arg-smart-charging"></a></dt>
<dd><p>SmartCharging object, returned by function <code><a href="smart_charging.html">smart_charging()</a></code></p></dd>


<dt id="arg-sessions">sessions<a class="anchor" aria-label="anchor" href="#arg-sessions"></a></dt>
<dd><p>tibble, sessions data set containig the following variables:
<code>"Session"</code>, <code>"Timecycle"</code>, <code>"Profile"</code>, <code>"ConnectionStartDateTime"</code>, <code>"ConnectionHours"</code>, <code>"Power"</code> and <code>"Energy"</code></p></dd>


<dt id="arg-show-setpoint">show_setpoint<a class="anchor" aria-label="anchor" href="#arg-show-setpoint"></a></dt>
<dd><p>logical, whether to show the setpoint line or not</p></dd>


<dt id="arg-by">by<a class="anchor" aria-label="anchor" href="#arg-by"></a></dt>
<dd><p>character, name of a character column in <code>smart_charging$sessions</code> (e.g. <code>"Profile"</code>) or
<code>"FlexType"</code> (i.e. "Exploited", "Not exploited", "Not flexible", "Not responsive" and "Not considered")</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>extra arguments of function <code><a href="https://resourcefully-dev.github.io/evsim/reference/plot_ts.html" class="external-link">evsim::plot_ts()</a></code> or other arguments
to pass to <code><a href="https://rdrr.io/pkg/dygraphs/man/dyOptions.html" class="external-link">dygraphs::dyOptions()</a></code>.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>dygraphs plot</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org" class="external-link">dplyr</a></span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">sessions</span> <span class="op">&lt;-</span> <span class="fu">evsim</span><span class="fu">::</span><span class="va"><a href="https://resourcefully-dev.github.io/evsim/reference/california_ev_sessions_profiles.html" class="external-link">california_ev_sessions_profiles</a></span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/slice.html" class="external-link">slice_head</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">50</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span></span></span>
<span class="r-in"><span>  <span class="fu">evsim</span><span class="fu">::</span><span class="fu"><a href="https://resourcefully-dev.github.io/evsim/reference/adapt_charging_features.html" class="external-link">adapt_charging_features</a></span><span class="op">(</span>time_resolution <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">sessions_demand</span> <span class="op">&lt;-</span> <span class="fu">evsim</span><span class="fu">::</span><span class="fu"><a href="https://resourcefully-dev.github.io/evsim/reference/get_demand.html" class="external-link">get_demand</a></span><span class="op">(</span><span class="va">sessions</span>, resolution <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Don't require any other variable than datetime, since we don't</span></span></span>
<span class="r-in"><span><span class="co"># care about local generation (just peak shaving objective)</span></span></span>
<span class="r-in"><span><span class="va">opt_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html" class="external-link">tibble</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  datetime <span class="op">=</span> <span class="va">sessions_demand</span><span class="op">$</span><span class="va">datetime</span>,</span></span>
<span class="r-in"><span>  production <span class="op">=</span> <span class="fl">0</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">sc_results</span> <span class="op">&lt;-</span> <span class="fu"><a href="smart_charging.html">smart_charging</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">sessions</span>, <span class="va">opt_data</span>,</span></span>
<span class="r-in"><span>  opt_objective <span class="op">=</span> <span class="st">"grid"</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"curtail"</span>,</span></span>
<span class="r-in"><span>  window_days <span class="op">=</span> <span class="fl">1</span>, window_start_hour <span class="op">=</span> <span class="fl">6</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Plot of setpoint and final EV demand</span></span></span>
<span class="r-in"><span><span class="fu">plot_smart_charging</span><span class="op">(</span><span class="va">sc_results</span>, legend_show <span class="op">=</span> <span class="st">"onmouseover"</span><span class="op">)</span></span></span>
<div id="htmlwidget-10b3b7155e8045a1b2ad" style="width:700px;height:432.632880098888px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-10b3b7155e8045a1b2ad">{"x":{"attrs":{"ylabel":"Power (kW)","labels":["minute","Setpoint","Flexible EVs"],"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true}},"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":false,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","navy"],"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Flexible EVs":{"axis":"y"}}},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.26,23.26,23.26,23.25,23.25,23.24,23.24,23.44,23.53,23.39,23.24,23.46,23.24,24.22,24.4,25.68,25.98,25.98,25.98,25.98,26.82,30.51,30.51,30.51,30.51,31.91,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,47.67999999999999,38.18000000000001,30.11,22.01,9.77,7.67,6.43,6.43,6.43,6.43,5.99,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":[],"jsHooks":[]}</script><span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Native `plot` function also works</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">sc_results</span>, legend_show <span class="op">=</span> <span class="st">"onmouseover"</span><span class="op">)</span></span></span>
<div id="htmlwidget-4018eef1a407a0df6b52" style="width:700px;height:432.632880098888px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-4018eef1a407a0df6b52">{"x":{"attrs":{"ylabel":"Power (kW)","labels":["minute","Setpoint","Flexible EVs"],"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true}},"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":false,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","navy"],"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Flexible EVs":{"axis":"y"}}},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.26,23.26,23.26,23.25,23.25,23.24,23.24,23.44,23.53,23.39,23.24,23.46,23.24,24.22,24.4,25.68,25.98,25.98,25.98,25.98,26.82,30.51,30.51,30.51,30.51,31.91,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,47.67999999999999,38.18000000000001,30.11,22.01,9.77,7.67,6.43,6.43,6.43,6.43,5.99,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":[],"jsHooks":[]}</script><span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Plot with original demand line</span></span></span>
<span class="r-in"><span><span class="fu">plot_smart_charging</span><span class="op">(</span><span class="va">sc_results</span>, sessions <span class="op">=</span> <span class="va">sessions</span>, legend_show <span class="op">=</span> <span class="st">"onmouseover"</span><span class="op">)</span></span></span>
<div id="htmlwidget-5b1b2f4ad92281566982" style="width:700px;height:432.632880098888px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-5b1b2f4ad92281566982">{"x":{"attrs":{"ylabel":"Power (kW)","labels":["minute","Setpoint","Flexible EVs","Original EVs"],"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true}},"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":false,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","navy","gray"],"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Flexible EVs":{"axis":"y"},"Original EVs":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]}}},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.26,23.26,23.26,23.25,23.25,23.24,23.24,23.44,23.53,23.39,23.24,23.46,23.24,24.22,24.4,25.68,25.98,25.98,25.98,25.98,26.82,30.51,30.51,30.51,30.51,31.91,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,47.67999999999999,38.18000000000001,30.11,22.01,9.77,7.67,6.43,6.43,6.43,6.43,5.99,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,27.84999999999999,29.38,29.38,29.38,29.38,29.38,29.38,29.38,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,44.91,22.68,18.52,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.03,0.35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":[],"jsHooks":[]}</script><span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Plot by "FlexType"</span></span></span>
<span class="r-in"><span><span class="fu">plot_smart_charging</span><span class="op">(</span><span class="va">sc_results</span>, sessions <span class="op">=</span> <span class="va">sessions</span>, by <span class="op">=</span> <span class="st">"FlexType"</span>, legend_show <span class="op">=</span> <span class="st">"onmouseover"</span><span class="op">)</span></span></span>
<div id="htmlwidget-25c3e940e6859592f801" style="width:700px;height:432.632880098888px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-25c3e940e6859592f801">{"x":{"attrs":{"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true,"valueRange":[0,86.667]}},"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Not considered":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Not flexible":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Not exploited":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Exploited":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Original EVs":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]}},"ylabel":"Power (kW)","labels":["minute","Setpoint","Not considered","Not flexible","Not exploited","Exploited","Original EVs"],"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":false,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","#660066","#003300","#663300","#ff9900","gray"]},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6.17,6.17,6.17,6.17,8.289999999999999,9.049999999999999,9.549999999999999,9.549999999999999,9.549999999999999,11.21,13.3,15.83,15.83,17.54,18.32,21.38,21.38,22.96,22.96,22.96,22.96,22.96,24.32,24.32,24.32,24.32,24.32,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,32.65,32.65,35.68,29.04,22.66,18.84,9.77,7.67,6.43,6.43,6.43,6.43,5.99,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,12.91,0,0,0,0,0,0,0,0,0,0,0,0,0,1.49,3.02,3.02,3.02,3.02,3.02,3.02,3.02,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,12.16,12.16,12,9.140000000000001,7.45,3.17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17.09,17.09,17.09,14.96,14.2,13.69,13.69,13.89,12.32,10.09,7.41,7.63,5.7,4.41,0,1.28,0,0,0,0,0.84,0,0,0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,27.84999999999999,29.38,29.38,29.38,29.38,29.38,29.38,29.38,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,44.91,22.68,18.52,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.03,0.35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":["attrs.series.Not considered.plotter","attrs.series.Not flexible.plotter","attrs.series.Not exploited.plotter","attrs.series.Exploited.plotter"],"jsHooks":[]}</script><span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Plot by user "Profile"</span></span></span>
<span class="r-in"><span><span class="fu">plot_smart_charging</span><span class="op">(</span><span class="va">sc_results</span>, sessions <span class="op">=</span> <span class="va">sessions</span>, by <span class="op">=</span> <span class="st">"Profile"</span>, legend_show <span class="op">=</span> <span class="st">"onmouseover"</span><span class="op">)</span></span></span>
<div id="htmlwidget-3f27c09be0c60bb52829" style="width:700px;height:432.632880098888px;" class="dygraphs html-widget"></div>
<script type="application/json" data-for="htmlwidget-3f27c09be0c60bb52829">{"x":{"attrs":{"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true,"valueRange":[0,86.667]}},"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Worktime":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"WorktimeVisit"},"Visit":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"WorktimeVisit"},"Original EVs":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]}},"ylabel":"Power (kW)","labels":["minute","Setpoint","Worktime","Visit","Original EVs"],"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":false,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","#003380","#008033","gray"]},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.26,23.26,23.26,23.25,23.25,23.24,23.24,23.44,23.53,23.39,23.24,23.46,23.24,22.73,21.38,22.66,22.96,22.96,22.96,22.96,23.8,24.32,24.32,24.32,24.32,25.72,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,19.43,13.34,9.520000000000001,6.73,4.640000000000001,3.4,3.4,3.4,3.4,2.96,2.04,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.77,5.529999999999999,7.93,15.83,23.37,23.37,24.13000000000001,35.98,44.49,71.55000000000001,73.93000000000001,73.93000000000001,73.93000000000001,73.93000000000001,73.93000000000001,69.42,58.31000000000002,52.37,50.69000000000001,46.31000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.49,3.02,3.02,3.02,3.02,3.02,3.02,3.02,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,18.45,18.45,21.32,18.75,16.77,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.03,0.23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.57,2.57,5.43,5.43,5.43,8.609999999999999,8.609999999999999,8.609999999999999,8.609999999999999,8.609999999999999,8.609999999999999,8.25,5.75,5.75,5.75,5.75,5.75,5.75,5.75,2.53,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,27.84999999999999,29.38,29.38,29.38,29.38,29.38,29.38,29.38,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,44.91,22.68,18.52,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.03,0.35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":["attrs.series.Worktime.plotter","attrs.series.Visit.plotter"],"jsHooks":[]}</script><span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Marc Cañigueral.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

