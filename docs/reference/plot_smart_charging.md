# Plot smart charging results

HTML interactive plot showing the comparison between the smart charging
setpoint and the actual EV demand after the smart charging program.
Also, it is possible to plot the original EV demand.

## Usage

``` r
plot_smart_charging(
  smart_charging,
  sessions = NULL,
  show_setpoint = TRUE,
  by = NULL,
  ...
)
```

## Arguments

- smart_charging:

  SmartCharging object, returned by function
  [`smart_charging()`](https://resourcefully-dev.github.io/flextools/reference/smart_charging.md)

- sessions:

  tibble, sessions data set containig the following variables:
  `"Session"`, `"Timecycle"`, `"Profile"`, `"ConnectionStartDateTime"`,
  `"ConnectionHours"`, `"Power"` and `"Energy"`

- show_setpoint:

  logical, whether to show the setpoint line or not

- by:

  character, name of a character column in `smart_charging$sessions`
  (e.g. `"Profile"`) or `"FlexType"` (i.e. "Exploited", "Not exploited",
  "Not flexible", "Not responsive" and "Not considered")

- ...:

  extra arguments of function
  [`timefully::plot_ts()`](https://resourcefully-dev.github.io/timefully/reference/plot_ts.html)
  or other arguments to pass to
  [`dygraphs::dyOptions()`](https://rdrr.io/pkg/dygraphs/man/dyOptions.html).

## Value

dygraphs plot

## Examples

``` r
library(dplyr)
sessions <- evsim::california_ev_sessions_profiles %>%
  slice_head(n = 50) %>%
  evsim::adapt_charging_features(time_resolution = 15)
sessions_demand <- evsim::get_demand(sessions, resolution = 15)

# Don't require any other variable than datetime, since we don't
# care about local generation (just peak shaving objective)
opt_data <- tibble(
  datetime = sessions_demand$datetime,
  production = 0
)

sc_results <- smart_charging(
  sessions, opt_data,
  opt_objective = "grid",
  method = "curtail",
  window_days = 1, window_start_hour = 6
)

# Plot of setpoint and final EV demand
plot_smart_charging(sc_results, legend_show = "onmouseover")

{"x":{"attrs":{"ylabel":"Power (kW)","labels":["minute","Setpoint","Flexible EVs"],"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true}},"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":true,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","navy"],"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Flexible EVs":{"axis":"y"}}},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25999999999999,23.24999999999999,23.26,23.26000000000001,23.26,23.25,23.28,23.23,23.26,23.24999999999999,23.26,23.25,23.24,23.25,24.72,25.98,25.98,25.98,25.98,26.11,27.34,30.51,30.51,30.51,30.85,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,47.66,37.95999999999999,30,21.97,9.720000000000001,7.609999999999999,6.43,6.43,6.43,6.43,5.98,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":[],"jsHooks":[]}
# Native `plot` function also works
plot(sc_results, legend_show = "onmouseover")

{"x":{"attrs":{"ylabel":"Power (kW)","labels":["minute","Setpoint","Flexible EVs"],"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true}},"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":true,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","navy"],"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Flexible EVs":{"axis":"y"}}},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25999999999999,23.24999999999999,23.26,23.26000000000001,23.26,23.25,23.28,23.23,23.26,23.24999999999999,23.26,23.25,23.24,23.25,24.72,25.98,25.98,25.98,25.98,26.11,27.34,30.51,30.51,30.51,30.85,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,47.66,37.95999999999999,30,21.97,9.720000000000001,7.609999999999999,6.43,6.43,6.43,6.43,5.98,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":[],"jsHooks":[]}
# Plot with original demand line
plot_smart_charging(sc_results, sessions = sessions, legend_show = "onmouseover")

{"x":{"attrs":{"ylabel":"Power (kW)","labels":["minute","Setpoint","Flexible EVs","Original EVs"],"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true}},"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":true,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","navy","gray"],"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Flexible EVs":{"axis":"y"},"Original EVs":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]}}},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25999999999999,23.24999999999999,23.26,23.26000000000001,23.26,23.25,23.28,23.23,23.26,23.24999999999999,23.26,23.25,23.24,23.25,24.72,25.98,25.98,25.98,25.98,26.11,27.34,30.51,30.51,30.51,30.85,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,47.66,37.95999999999999,30,21.97,9.720000000000001,7.609999999999999,6.43,6.43,6.43,6.43,5.98,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,27.84999999999999,29.38,29.38,29.38,29.38,29.38,29.38,29.38,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,44.91,22.68,18.52,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.03,0.35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":[],"jsHooks":[]}
# Plot by "FlexType"
plot_smart_charging(sc_results, sessions = sessions, by = "FlexType", legend_show = "onmouseover")

{"x":{"attrs":{"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true,"valueRange":[0,86.667]}},"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Not considered":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Not flexible":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Not exploited":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Exploited":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"Not consideredNot flexibleNot exploitedExploited"},"Original EVs":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]}},"ylabel":"Power (kW)","labels":["minute","Setpoint","Not considered","Not flexible","Not exploited","Exploited","Original EVs"],"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":true,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","#660066","#003300","#663300","#ff9900","gray"]},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6.17,6.17,6.17,6.17,6.17,6.17,6.17,6.17,6.77,8.029999999999999,8.029999999999999,9.549999999999999,9.549999999999999,9.549999999999999,13.3,19.19,22.96,22.96,22.96,22.96,22.96,24.32,24.32,24.32,24.32,24.32,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,32.65,32.65,35.66,28.82,22.55,18.8,9.720000000000001,7.609999999999999,6.43,6.43,6.43,6.43,5.98,2.27,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,12.91,0,0,0,0,0,0,0,0,0,0,0,0,0,1.49,3.02,3.02,3.02,3.02,3.02,3.02,3.02,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,12.16,12.16,12,9.140000000000001,7.45,3.17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17.09,17.08,17.09,17.09,17.09,17.08,17.11,16.46,15.23,15.22,13.71,13.7,13.69,8.460000000000001,2.51,0,0,0,0,0.13,0,0,0,0,0.34,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,27.84999999999999,29.38,29.38,29.38,29.38,29.38,29.38,29.38,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,44.91,22.68,18.52,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.03,0.35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":["attrs.series.Not considered.plotter","attrs.series.Not flexible.plotter","attrs.series.Not exploited.plotter","attrs.series.Exploited.plotter"],"jsHooks":[]}
# Plot by user "Profile"
plot_smart_charging(sc_results, sessions = sessions, by = "Profile", legend_show = "onmouseover")

{"x":{"attrs":{"axes":{"x":{"pixelsPerLabel":60,"drawAxis":true},"y":{"drawAxis":true,"valueRange":[0,86.667]}},"series":{"Setpoint":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]},"Worktime":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"WorktimeVisit"},"Visit":{"axis":"y","plotter":"// the _lineplotter function extracted from dygraphs-combined-dev.js, available for use in conjunction with other per-series plotters and group plotters\n\nfunction linePlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  // END HEADER BLOCK\n\t\n\t//Stack the points\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n  \n\t// Helper function to trace a line back along the baseline.\n  var traceBackPath = function(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n    for (var i = pathBack.length - 1; i >= 0; i--) {\n      var pt = pathBack[i];\n      ctx.lineTo(pt[0], pt[1]);\n    }\n  };\n  \n\t// Do the actual plotting.\n\t\t\t\t// First, we'll plot the line for this series, then...\n\t\t\t\t// Second, we'll add the fills\n\t\t\t\t// In contrast to stackedlinegroup, we do this in reverse\n\t\t\t\t// order to align with the fillplotter\n\tvar area = e.plotArea;\n  var fillAlpha = g.getNumericOption('fillAlpha');\n\t\n\tvar baseline = {};\n  var currBaseline;\n  var prevStepPlot;  // for different line drawing modes (line/step) per series\n\n  var ctx = e.drawingContext;\n    \n\t// For filled charts, we draw points from left to right, then back along\n  // the x-axis to complete a shape for filling.\n  // For stacked plots, this \"back path\" is a more complex shape. This array\n  // stores the [x, y] values needed to trace that shape.\n  var pathBack = [];\n\n\t//We'll save the group indices of the current set,\n\t\t\t\t// so as to test later and hopefully skip \n\t\t\t\t// past needless iterations of the loops\n\tvar currSetIdx;\n\t//Now a quick FOR loop to capture the group indices\n  for (var j = sets.length - 1; j >= 0; j--) {\n    seriesName = groupSetNames[j]; \n\t\tif (seriesName === e.setName) currSetIdx = j;\n  }\n  \n\tfor (var j = sets.length - 1; j >= 0; j--) {\n\t\t// If we're not dealing with the immediate plotted series or it's\n\t\t\t\t\t// immediate predecesor, skip all this stuff below\n\t\tif (j > (currSetIdx + 1) || j < currSetIdx) continue;\n\n    setName = groupSetNames[j];\n\n\t\tvar connectSeparated = g.getOption('connectSeparatedPoints', setName);\n    var logscale = g.attributes_.getForSeries(\"logscale\", setName);\n    \n    axis = g.axisPropertiesForSeries(setName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n\t\t}\n\n\t\te.points = points;\n\n\t  var strokeWidth = e.strokeWidth;\n\t\n\t  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n\t  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) ||\n\t      Dygraph.Circles.DEFAULT;\n\t  var strokePattern = g.getOption(\"strokePattern\", setName);\n\t  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n\t  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\t\t\n\t\t// We'll only draw the line plotter if the current series matches\n\t\t\t\t\t// the one in the top-level plotter call\n\t\tif (setName === e.setName) {\n\t  \tif (borderWidth && strokeWidth) {\n\t  \t  DygraphCanvasRenderer._drawStyledLine(e,\n\t  \t      g.getOption(\"strokeBorderColor\", setName),\n\t  \t      strokeWidth + 2 * borderWidth,\n\t  \t      strokePattern,\n\t  \t      drawPoints,\n\t  \t      drawPointCallback,\n\t  \t      pointSize\n\t  \t      );\n\t  \t}\n\t\n\t  \tDygraphCanvasRenderer._drawStyledLine(e,\n\t  \t    e.color,\n\t  \t    strokeWidth,\n\t  \t    strokePattern,\n\t  \t    drawPoints,\n\t  \t    drawPointCallback,\n\t  \t    pointSize\n\t  \t);\n\t\t}\n\t\t//END OF THE LINE PLOTTER\n\t\t\t\t\t//\n\t\t//BEGIN THE FILL\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n\t\tvar color = e.color;\n\t\tvar axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;\n    else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n\n\n\t\t// setup graphics context\n  \tvar prevX = NaN;\n  \tvar prevYs = [-1, -1];\n  \tvar newYs;\n  \t\n\t\t// should be same color as the lines but only 15% opaque.\n  \tvar rgb = Dygraph.toRGB_(color);\n  \tvar err_color =\n  \t    'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    \n\n    var iter = Dygraph.createIterator(points, 0, points.length,\n        DygraphCanvasRenderer._getIteratorPredicate(\n            g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x, is_first = true;\n\n    // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n    if (points.length > 2 * g.width_ || Dygraph.FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    }\n\n    // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n    var point;\n\n\t\t// Throughout this loop, we test to see if the top-level called series\n\t\t\t\t\t// matches the one current in the parent FOR loop.  If not, we skip\n\t\t\t\t\t// the parts that draw the line but leave the others so the pathback\n\t\t\t\t\t// and prevYs and prevXs still get properly populated\n    while (iter.hasNext) {\n      point = iter.next();\n      if (!Dygraph.isOK(point.y) && !stepPlot) {\n\t\t\t\t//\n        if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\t\tctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n        continue;\n      }\n      if (!is_first && last_x == point.xval) {\n        continue;\n      } else {\n        is_first = false;\n        last_x = point.xval;\n      }\n\n      currBaseline = baseline[point.canvasx];\n      var lastY;\n      if (currBaseline === undefined) {\n        lastY = axisY;\n      } else {\n        if(prevStepPlot) {\n          lastY = currBaseline[0];\n        } else {\n          lastY = currBaseline;\n        }\n      }\n      newYs = [ point.canvasy, lastY ];\n\n      if (stepPlot) {\n        // Step plots must keep track of the top and bottom of\n        // the baseline at each point.\n        if (prevYs[0] === -1) {\n          baseline[point.canvasx] = [ point.canvasy, axisY ];\n        } else {\n          baseline[point.canvasx] = [ point.canvasy, prevYs[0] ];\n        }\n      } else {\n        baseline[point.canvasx] = point.canvasy;\n      }\n\n      if (!isNaN(prevX)) {\n\t\t\t\tif (e.setName === setName) {\n        \t// Move to top fill point\n        \tif (stepPlot) {\n        \t  ctx.lineTo(point.canvasx, prevYs[0]);\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t} else {\n        \t  ctx.lineTo(point.canvasx, newYs[0]);\n        \t}\n        }\n\n        // Record the baseline for the reverse path.\n        pathBack.push([prevX, prevYs[1]]);\n        if (prevStepPlot && currBaseline) {\n          // Draw to the bottom of the baseline\n          pathBack.push([point.canvasx, currBaseline[1]]);\n        } else {\n          pathBack.push([point.canvasx, newYs[1]]);\n        }\n      } else if (e.setName === setName) {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n      prevYs = newYs;\n      prevX = point.canvasx;\n\t\t}\n    prevStepPlot = stepPlot;\n    if (newYs && point) {\n      if (e.setName === setName) traceBackPath(\n\t\t\t\t\t\t\tctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n    ctx.fill();\n\t}\n}","group":"WorktimeVisit"},"Original EVs":{"axis":"y","strokeWidth":2,"strokePattern":[7,3]}},"ylabel":"Power (kW)","labels":["minute","Setpoint","Worktime","Visit","Original EVs"],"legend":"onmouseover","labelsDivWidth":250,"labelsShowZeroValues":true,"labelsSeparateLines":false,"hideOverlayOnMouseOut":true,"stackedGraph":false,"fillGraph":false,"fillAlpha":0.15,"stepPlot":false,"drawPoints":false,"pointSize":1,"drawGapEdgePoints":false,"connectSeparatedPoints":false,"strokeWidth":2,"strokeBorderColor":"white","colorValue":0.5,"colorSaturation":1,"includeZero":false,"drawAxesAtZero":false,"logscale":false,"axisTickSize":3,"axisLineColor":"black","axisLineWidth":0.3,"axisLabelColor":"black","axisLabelFontSize":14,"axisLabelWidth":60,"drawGrid":true,"gridLineWidth":0.3,"rightGap":5,"digitsAfterDecimal":2,"labelsKMB":false,"labelsKMG2":false,"labelsUTC":false,"maxNumberWidth":6,"animatedZooms":false,"mobileDisableYTouch":true,"retainDateWindow":true,"disableZoom":false,"colors":["red","#003380","#008033","gray"]},"scale":"minute","annotations":[],"shadings":[],"events":[],"format":"date","data":[["2018-10-08T07:00:00.000Z","2018-10-08T07:15:00.000Z","2018-10-08T07:30:00.000Z","2018-10-08T07:45:00.000Z","2018-10-08T08:00:00.000Z","2018-10-08T08:15:00.000Z","2018-10-08T08:30:00.000Z","2018-10-08T08:45:00.000Z","2018-10-08T09:00:00.000Z","2018-10-08T09:15:00.000Z","2018-10-08T09:30:00.000Z","2018-10-08T09:45:00.000Z","2018-10-08T10:00:00.000Z","2018-10-08T10:15:00.000Z","2018-10-08T10:30:00.000Z","2018-10-08T10:45:00.000Z","2018-10-08T11:00:00.000Z","2018-10-08T11:15:00.000Z","2018-10-08T11:30:00.000Z","2018-10-08T11:45:00.000Z","2018-10-08T12:00:00.000Z","2018-10-08T12:15:00.000Z","2018-10-08T12:30:00.000Z","2018-10-08T12:45:00.000Z","2018-10-08T13:00:00.000Z","2018-10-08T13:15:00.000Z","2018-10-08T13:30:00.000Z","2018-10-08T13:45:00.000Z","2018-10-08T14:00:00.000Z","2018-10-08T14:15:00.000Z","2018-10-08T14:30:00.000Z","2018-10-08T14:45:00.000Z","2018-10-08T15:00:00.000Z","2018-10-08T15:15:00.000Z","2018-10-08T15:30:00.000Z","2018-10-08T15:45:00.000Z","2018-10-08T16:00:00.000Z","2018-10-08T16:15:00.000Z","2018-10-08T16:30:00.000Z","2018-10-08T16:45:00.000Z","2018-10-08T17:00:00.000Z","2018-10-08T17:15:00.000Z","2018-10-08T17:30:00.000Z","2018-10-08T17:45:00.000Z","2018-10-08T18:00:00.000Z","2018-10-08T18:15:00.000Z","2018-10-08T18:30:00.000Z","2018-10-08T18:45:00.000Z","2018-10-08T19:00:00.000Z","2018-10-08T19:15:00.000Z","2018-10-08T19:30:00.000Z","2018-10-08T19:45:00.000Z","2018-10-08T20:00:00.000Z","2018-10-08T20:15:00.000Z","2018-10-08T20:30:00.000Z","2018-10-08T20:45:00.000Z","2018-10-08T21:00:00.000Z","2018-10-08T21:15:00.000Z","2018-10-08T21:30:00.000Z","2018-10-08T21:45:00.000Z","2018-10-08T22:00:00.000Z","2018-10-08T22:15:00.000Z","2018-10-08T22:30:00.000Z","2018-10-08T22:45:00.000Z","2018-10-08T23:00:00.000Z","2018-10-08T23:15:00.000Z","2018-10-08T23:30:00.000Z","2018-10-08T23:45:00.000Z","2018-10-09T00:00:00.000Z","2018-10-09T00:15:00.000Z","2018-10-09T00:30:00.000Z","2018-10-09T00:45:00.000Z","2018-10-09T01:00:00.000Z","2018-10-09T01:15:00.000Z","2018-10-09T01:30:00.000Z","2018-10-09T01:45:00.000Z","2018-10-09T02:00:00.000Z","2018-10-09T02:15:00.000Z","2018-10-09T02:30:00.000Z","2018-10-09T02:45:00.000Z","2018-10-09T03:00:00.000Z","2018-10-09T03:15:00.000Z","2018-10-09T03:30:00.000Z","2018-10-09T03:45:00.000Z","2018-10-09T04:00:00.000Z","2018-10-09T04:15:00.000Z","2018-10-09T04:30:00.000Z","2018-10-09T04:45:00.000Z","2018-10-09T05:00:00.000Z","2018-10-09T05:15:00.000Z","2018-10-09T05:30:00.000Z","2018-10-09T05:45:00.000Z","2018-10-09T06:00:00.000Z","2018-10-09T06:15:00.000Z","2018-10-09T06:30:00.000Z","2018-10-09T06:45:00.000Z","2018-10-09T07:00:00.000Z","2018-10-09T07:15:00.000Z","2018-10-09T07:30:00.000Z","2018-10-09T07:45:00.000Z","2018-10-09T08:00:00.000Z","2018-10-09T08:15:00.000Z","2018-10-09T08:30:00.000Z","2018-10-09T08:45:00.000Z","2018-10-09T09:00:00.000Z","2018-10-09T09:15:00.000Z","2018-10-09T09:30:00.000Z","2018-10-09T09:45:00.000Z","2018-10-09T10:00:00.000Z","2018-10-09T10:15:00.000Z","2018-10-09T10:30:00.000Z","2018-10-09T10:45:00.000Z","2018-10-09T11:00:00.000Z","2018-10-09T11:15:00.000Z","2018-10-09T11:30:00.000Z","2018-10-09T11:45:00.000Z","2018-10-09T12:00:00.000Z","2018-10-09T12:15:00.000Z","2018-10-09T12:30:00.000Z","2018-10-09T12:45:00.000Z","2018-10-09T13:00:00.000Z","2018-10-09T13:15:00.000Z","2018-10-09T13:30:00.000Z","2018-10-09T13:45:00.000Z","2018-10-09T14:00:00.000Z","2018-10-09T14:15:00.000Z","2018-10-09T14:30:00.000Z","2018-10-09T14:45:00.000Z","2018-10-09T15:00:00.000Z","2018-10-09T15:15:00.000Z","2018-10-09T15:30:00.000Z","2018-10-09T15:45:00.000Z","2018-10-09T16:00:00.000Z","2018-10-09T16:15:00.000Z","2018-10-09T16:30:00.000Z","2018-10-09T16:45:00.000Z","2018-10-09T17:00:00.000Z","2018-10-09T17:15:00.000Z","2018-10-09T17:30:00.000Z","2018-10-09T17:45:00.000Z","2018-10-09T18:00:00.000Z","2018-10-09T18:15:00.000Z","2018-10-09T18:30:00.000Z","2018-10-09T18:45:00.000Z","2018-10-09T19:00:00.000Z","2018-10-09T19:15:00.000Z","2018-10-09T19:30:00.000Z","2018-10-09T19:45:00.000Z","2018-10-09T20:00:00.000Z","2018-10-09T20:15:00.000Z","2018-10-09T20:30:00.000Z","2018-10-09T20:45:00.000Z","2018-10-09T21:00:00.000Z","2018-10-09T21:15:00.000Z","2018-10-09T21:30:00.000Z","2018-10-09T21:45:00.000Z","2018-10-09T22:00:00.000Z","2018-10-09T22:15:00.000Z","2018-10-09T22:30:00.000Z","2018-10-09T22:45:00.000Z","2018-10-09T23:00:00.000Z","2018-10-09T23:15:00.000Z","2018-10-09T23:30:00.000Z","2018-10-09T23:45:00.000Z","2018-10-10T00:00:00.000Z","2018-10-10T00:15:00.000Z","2018-10-10T00:30:00.000Z","2018-10-10T00:45:00.000Z","2018-10-10T01:00:00.000Z","2018-10-10T01:15:00.000Z","2018-10-10T01:30:00.000Z","2018-10-10T01:45:00.000Z","2018-10-10T02:00:00.000Z","2018-10-10T02:15:00.000Z","2018-10-10T02:30:00.000Z","2018-10-10T02:45:00.000Z","2018-10-10T03:00:00.000Z","2018-10-10T03:15:00.000Z","2018-10-10T03:30:00.000Z","2018-10-10T03:45:00.000Z","2018-10-10T04:00:00.000Z","2018-10-10T04:15:00.000Z","2018-10-10T04:30:00.000Z","2018-10-10T04:45:00.000Z","2018-10-10T05:00:00.000Z","2018-10-10T05:15:00.000Z","2018-10-10T05:30:00.000Z","2018-10-10T05:45:00.000Z","2018-10-10T06:00:00.000Z","2018-10-10T06:15:00.000Z","2018-10-10T06:30:00.000Z","2018-10-10T06:45:00.000Z","2018-10-10T07:00:00.000Z"],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,23.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.74000000000001,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,23.25999999999999,23.24999999999999,23.26,23.26000000000001,23.26,23.25,23.28,23.23,23.26,23.24999999999999,23.26,23.25,23.24,21.76,21.7,22.96,22.96,22.96,22.96,23.09,24.32,24.32,24.32,24.32,24.66,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.34,19.21,13.23,9.48,6.680000000000001,4.58,3.4,3.4,3.4,3.4,2.96,2.04,2.04,2.04,2.04,1.39,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.77,5.529999999999999,7.93,15.83,23.37,23.37,24.13000000000001,35.98,44.49,71.55000000000001,73.93000000000001,73.93000000000001,73.93000000000001,73.93000000000001,73.93000000000001,69.42,58.31000000000002,52.37,50.69000000000001,46.31000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.49,3.02,3.02,3.02,3.02,3.02,3.02,3.02,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,6.19,18.45,18.45,21.32,18.75,16.77,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.02,0.23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.57,2.57,5.43,5.43,5.43,8.609999999999999,8.609999999999999,8.609999999999999,8.609999999999999,8.609999999999999,8.609999999999999,8.25,5.75,5.75,5.75,5.75,5.75,5.75,5.75,2.53,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2.79,2.79,8.17,9.539999999999999,19.08,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,26.36,27.84999999999999,29.38,29.38,29.38,29.38,29.38,29.38,29.38,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,32.55,44.81,44.81,44.91,22.68,18.52,12.49,3.04,3.03,3.03,3.03,3.03,3.03,3.03,0.35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5.34,8.1,13.36,21.26,28.8,31.98,32.73999999999999,44.59,53.1,80.16000000000001,82.54000000000001,82.18000000000001,79.68000000000001,79.68000000000001,79.68000000000001,75.17,64.06000000000002,58.12,56.44000000000001,48.84000000000001,42.57,35.67,30.37,30.37,24.27,21.66,21.54,15.54,13.44,9.039999999999999,7.959999999999999,7.959999999999999,7.44,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,5.859999999999999,4.56,4.52,4.52,2.63,0.76,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],"fixedtz":true,"tzone":"America/Los_Angeles","css":"/* Dygraph styling */\n\n.dygraph-title {\n  text-align: left;\n  font-weight: normal;\n  font-size: 70%;\n}\n\n.dygraph-legend {\n  color: white;\n  background-color: #BABABA !important;\n    padding-left:5px;\n  border-color:#BABABA;\n    border-style:solid;\n  border-width:thin;\n  transition:0s 4s;\n  z-index: 20 !important;\n  box-shadow: 2px 2px 5px rgba(0, 0, 0, .3);\n  border-radius: 3px;\n}\n\n.dygraph-legend:hover{\n  transform: translate(-110%);\n  transition: 0s;\n}\n\n.dygraph-legend > span {\n  color: black;\n  padding-left:5px;\n  margin-left:-5px;\n  background-color: white !important;\n  display: block;\n}\n\n.dygraph-legend > span > span{\n  display: inline;\n}\n\n.highlight {\n  border-left: 2px solid #BABABA;\n  padding-left:3px !important;\n\n}"},"evals":["attrs.series.Worktime.plotter","attrs.series.Visit.plotter"],"jsHooks":[]}
```
